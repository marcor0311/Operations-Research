# -*- coding: utf-8 -*-<br>
&#34;&#34;&#34;ProgramacionLineal.ipynb<p>Automatically generated by Colab.</p><p>Original file is located at<br>
    <a href="https://colab.research.google.com/drive/1dru_74GUpEKBt2c48eMkcLdrf_ZOpG2Y">https://colab.research.google.com/drive/1dru_74GUpEKBt2c48eMkcLdrf_ZOpG2Y</a><br>
&#34;&#34;&#34;</p><p>import numpy as np<br>
import matplotlib.pyplot as plt<br>
from scipy.optimize import linprog, minimize, NonlinearConstraint</p><p>from re import T<br>
import numpy as np<br>
import matplotlib.pyplot as plt<br>
from scipy.optimize import linprog, minimize</p><p># Se realizan todas las verificaciones necesarias para que el sistema sea robusto<br>
# y no caiga debido a inputs incorrectos del usuario</p><p>def Lineal():<br>
    print(&#34;Vamos iniciar con la función objetivo&#34;)<br>
    string_optimizar = &#34;&#34;<br>
    cant_variables = 0<br>
    cant_restricciones = 0<br>
    funcion_objetivo = []<br><br>
    # Pedir si minimizar o maximizar (Continua si y sólo si lo ingresado es válido)<br>
    while(string_optimizar != &#34;MIN&#34; and string_optimizar != &#34;MAX&#34;):<br>
        string_optimizar = input(&#34;Si desea maximizar escriba: MAX y si quiere minimizar escriba MIN :&#34;).upper()<br><br>
    # Pedir cantidad de variables (2 o 3) (Continua si y sólo si lo ingresado es válido)<br>
    while(cant_variables != 2 and cant_variables != 3):<br>
        try:<br>
            cant_variables = int(input(&#34;Digite la cantidad de variables  (2 o 3): &#34;))<br>
        except ValueError:<br>
            print(&#34;Recuerde que solo se puede ingresar números&#34;)<br><br>
    # Pedir coeficientes de las variables (Continua si y sólo si lo ingresado es válido)<br>
    while(len(funcion_objetivo) != cant_variables):<br>
        try:<br>
            funcion_objetivo = list(map(int, input(f&#34;Ingrese los coeficientes de las {cant_variables} variables separados por espacio: &#34;).split()))<br>
        except ValueError:<br>
            print(&#34;Recuerde que solo se puede ingresar números&#34;)<br><br>
    # Si el problema es de maximización, invertimos el signo de la función objetivo<br>
    if string_optimizar == &#34;MAX&#34;:<br>
        funcion_objetivo = [-x for x in funcion_objetivo]<br><br>
    print(&#34;\nVamos a pedir las restricciones&#34;)<br><br>
    # Leer la cantidad de restricciones (Continua si y sólo si lo ingresado es válido)<br>
    while(cant_restricciones &lt;= 0):<br>
        try:<br>
            cant_restricciones = int(input(&#34;Ingrese la cantidad de restricciones: &#34;))<br>
        except ValueError:<br>
            print(&#34;Recuerde que solo se puede ingresar números&#34;)<br><br>
    lado_izq_restricciones = []<br>
    lado_der_restricciones = []<br><br>
    # Leer las restricciones, hace varias verificaciones (Continua si y sólo si lo ingresado es válido)<br>
    for i in range(cant_restricciones):<br>
        array_lado_izq = []<br>
        tipo_restriccion = &#34;&#34;<br>
        while len(array_lado_izq) != cant_variables:<br>
            try:<br>
                array_lado_izq = list(map(float, input(f&#34;Ingrese los coeficientes de la restricción {i+1} para cada variable: &#34;).split()))<br>
            except ValueError:<br>
                print(&#34;Recuerde que solo se puede ingresar números&#34;)<br><br>
        while tipo_restriccion not in (&#34;&lt;=&#34;, &#34;&gt;=&#34;):<br>
            tipo_restriccion = input(&#34;Escriba el tipo de restricción (&lt;= o &gt;=): &#34;)<br><br>
        valor_der = float(input(&#34;Ingrese el valor del lado derecho de la restricción: &#34;))<br><br>
        if tipo_restriccion == &#39;&gt;=&#39;:<br>
            # Multiplicamos por -1 para convertir a &lt;=<br>
            array_lado_izq = [-x for x in array_lado_izq]<br>
            valor_der = -valor_der<br><br>
        lado_izq_restricciones.append(array_lado_izq)<br>
        lado_der_restricciones.append(valor_der)<br><br>
    # Convertir listas a arrays numpy<br>
    A = np.array(lado_izq_restricciones)<br>
    b = np.array(lado_der_restricciones)<br><br>
    # Definir límites para las variables (no negativas)<br>
    bounds = [(0, None)] * cant_variables  # Todas las variables &gt;= 0<br><br>
    # Resolver el problema usando linprog<br>
    c = np.array(funcion_objetivo)<br>
    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method=&#39;highs&#39;)<br><br>
    # Mostrar resultados<br>
    if res.success:<br><br>
      if(cant_variables == 2):<br><br>
        optimo = (res.x[0], res.x[1])<br>
        x = np.linspace(0, 60, 10000)  # Valores de x para graficar<br>
        plt.figure()<br><br>
        # Graficar cada restricción<br>
        for i in range(cant_restricciones):<br>
          if A[i][1] != 0:  # Evitar división por cero<br>
            print(&#34;Bi&#34;,b[i])<br>
            print(&#34;Ai0&#34;,A[i][0])<br>
            print(&#34;Ai1&#34;,A[i][1])<br>
            y = (b[i] - A[i][0] * x) / A[i][1]  # Despejar y en términos de x<br>
            plt.plot(x, y, label=f&#34;Restricción {i+1}&#34;)<br>
          else:<br>
            # Si es una restricción de la forma ax &lt;= b, graficar una línea vertical<br>
            plt.axvline(x=b[i]/A[i][0], label=f&#34;Restricción {i+1}&#34;)<br><br>
        plt.xlim(bounds[0])<br>
        plt.ylim(bounds[1])<br><br>
        # Graficar el punto óptimo<br>
        plt.plot(optimo[0], optimo[1], &#39;ro&#39;, markersize=10)<br><br>
        plt.xlabel(&#39;x1&#39;)<br>
        plt.ylabel(&#39;x2&#39;)<br>
        plt.title(&#39;Restricciones y solución óptima&#39;)<br>
        plt.legend()<br>
        #plt.grid(True)<br>
        plt.show()<br><br>
      print(f&#34;El óptimo se alcanza en: {res.x} con un valor óptimo de {res.fun if string_optimizar == &#39;MIN&#39; else -res.fun}&#34;)<br>
    else:<br>
        print(&#34;No se encontró una solución óptima.&#34;)</p><p>def NoLineal():<br>
  &#34;&#34;&#34;<br>
  ejemplo<br>
Por SI o por NO: ¿Su función es lineal? no<br>
Digite la cantidad de variables (2, 3 o 4): 4<br>
Digite el valor inicial de la variable 1: 1<br>
Digite el valor inicial de la variable 2: 5<br>
Digite el valor inicial de la variable 3: 5<br>
Digite el valor inicial de la variable 4: 1<br>
Digite el valor mínimo para las variables: 1<br>
Digite el valor máximo para las variables: 5<br>
Digite si desea maximizar o minimizar: min<br>
Digite la función objetivo (por ejemplo: &#39;x[0]*x[1] + 10/x[2]&#39;): x[0]*x[3]*(x[0] + x[1] + x[2]) + x[2<br>
La función es errónea<br>
Digite la función objetivo (por ejemplo: &#39;x[0]*x[1] + 10/x[2]&#39;): x[0]*x[3]*(x[0] + x[1] + x[2]) + x[2]<br>
Digite la cantidad de restricciones (entre 0 y 10): 2<br>
Restricción 1<br>
    Digite la restricción (por ejemplo: &#39;x[0]*x[1] + 10/x[2]&#39;): x[0]*x[1]*x[2]*x[3]<br>
    Digite el valor inferior de la restricción [inferior &lt;= eval] (-INF, INF o un flotante): 25<br>
    Digite el valor superior de la restricción [eval &lt;= superior] (-INF, INF o un flotante): INF<br>
Restricción 2<br>
    Digite la restricción (por ejemplo: &#39;x[0]*x[1] + 10/x[2]&#39;): x[0]**2 + x[1]**2 + x[2]**2 + x[3]**2<br>
    Digite el valor inferior de la restricción [inferior &lt;= eval] (-INF, INF o un flotante): 40<br>
    Digite el valor superior de la restricción [eval &lt;= superior] (-INF, INF o un flotante): 40<br>
El óptimo se alcanza en: [1.         4.74299607 3.82115466 1.37940764] con un valor óptimo de 17.01401724556073<br>
  &#34;&#34;&#34;<br><br>
  def ObtenerNumero(mensaje, func=float):<br>
    while True:<br>
      try:<br>
        numero = func(input(mensaje))<br>
        return numero<br>
      except ValueError:<br>
        print(&#34;Recuerde que solo se puede ingresar números&#34;)<br><br>
  def ObtenerNumeroInf(mensaje):<br>
    while True:<br>
      try:<br>
        numero = input(mensaje)<br>
        if numero.upper() == &#34;-INF&#34;:<br>
          return -np.inf<br>
        if numero.upper() == &#34;INF&#34;:<br>
          return np.inf<br>
        return float(numero)<br>
      except ValueError:<br>
        print(&#34;Recuerde que solo se puede ingresar números&#34;)<br><br>
  def ObtenerNumeroRestr(mensaje, mn, mx, func=float):<br>
    while True:<br>
      try:<br>
        numero = func(input(mensaje))<br>
        if mn &lt;= numero &lt;= mx:<br>
          return numero<br>
      except ValueError:<br>
        print(&#34;Recuerde que solo se puede ingresar números&#34;)<br><br>
  def GetStr(mensaje, options=[]):<br>
    while True:<br>
      string = input(mensaje).upper()<br>
      if string in options or not options:<br>
        return string<br><br>
  def GetEval(mensaje, x0, noflip):<br>
    while True:<br>
      x1 = x0.copy()<br>
      string = input(mensaje)<br>
      fish = (lambda x: eval(string)) if noflip else (lambda x: -eval(string))<br>
      try:<br>
        if type(fish(x1)) == float:<br>
          return fish<br>
      except:<br>
        print(&#34;La función es errónea&#34;)<br><br><br>
  x0 = []<br><br>
  V = ObtenerNumeroRestr(&#34;Digite la cantidad de variables (2, 3 o 4): &#34;, 2, 4, int)<br>
  for i in range(V): x0.append(ObtenerNumero(f&#34;Digite el valor inicial de la variable {i+1}: &#34;))<br>
  min_bound = ObtenerNumero(&#34;Digite el valor mínimo para las variables: &#34;)<br>
  max_bound = ObtenerNumero(&#34;Digite el valor máximo para las variables: &#34;)<br>
  min_o_max = GetStr(&#34;Digite si desea maximizar o minimizar (min o max): &#34;, [&#34;MAX&#34;, &#34;MIN&#34;]) == &#34;MIN&#34;<br><br>
  objetivo = GetEval(&#34;Digite la función objetivo (por ejemplo: &#39;x[0]*x[1] + 10/x[2]&#39;): &#34;, x0, min_o_max)<br><br>
  r = ObtenerNumeroRestr(&#34;Digite la cantidad de restricciones (entre 0 y 10): &#34;, 0, 10, int)<br>
  rest = []<br>
  for _ in range(r):<br>
    print(f&#34;Restricción {_ + 1}&#34;)<br>
    base = GetEval(&#34;\tDigite la restricción (por ejemplo: &#39;x[0]*x[1] + 10/x[2]&#39;): &#34;, x0, min_o_max)<br>
    lower_bound = ObtenerNumeroInf(&#34;\tDigite el valor inferior de la restricción [inferior &lt;= eval] (-INF, INF o un flotante): &#34;)<br>
    upper_bound = ObtenerNumeroInf(&#34;\tDigite el valor superior de la restricción [eval &lt;= superior] (-INF, INF o un flotante): &#34;)<br><br>
    if min_o_max: rest.append(NonlinearConstraint(base, lower_bound, upper_bound))<br>
    else: rest.append(NonlinearConstraint(base, -upper_bound, -lower_bound))<br><br>
  bounds = [(min_bound, max_bound)] * V<br>
  res = minimize(objetivo, x0, bounds=bounds, constraints=rest)<br>
  if res.success:<br>
    print(f&#34;El óptimo se alcanza en: {res.x} con un valor óptimo de {res.fun if min_o_max else -res.fun}&#34;)<br>
  else:<br>
    print(&#34;No se encontró una solución óptima.&#34;)</p><p>R = input(&#34;Por SI o por NO: ¿Su función es lineal? &#34;).upper()</p><p>if R == &#34;SI&#34;:<br>
    Lineal()<br>
elif R == &#34;NO&#34;:<br>
    NoLineal()<br>
else:<br>
    print(&#34;Error&#34;)</p>
