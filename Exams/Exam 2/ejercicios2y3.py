# -*- coding: utf-8 -*-
"""Examen 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13jqEk7IywMkwzI88tFWeyTqdEZgHqiMV
"""

#include from algorithm min_max_latysh mml

# EJERCICIO 2

import numpy as np
from scipy.optimize import minimize
from scipy.optimize import NonlinearConstraint

# Función objetivo
def objetivo(x):
    return -x[0]*x[1]-2*pow(x[2],2)

# Condiciones iniciales (valores aproximados para empezar)
x0 = [30, 30, 30]  # Establecemos valores iniciales para x, y, z

rest1 = NonlinearConstraint(lambda x: -((x[0] * 5) + (x[1] * 20) + (x[2] * 4)), -120, 0)
rest2 = NonlinearConstraint(lambda x: -x[0], -np.inf, -5)
rest3 = NonlinearConstraint(lambda x: -x[1], -10, 0)
rest4 = NonlinearConstraint(lambda x: -x[2], -np.inf, 0)

# Resolver el problema de optimización
resultado = minimize(objetivo, x0, constraints=[rest1, rest2, rest3, rest4])

# Mostrar los resultados
if resultado.success:
    print("Solución óptima encontrada:")
    print(f"x = {resultado.x[0]}, y = {resultado.x[1]}, z = {resultado.x[2]}")
    print("Solución con redondeo")
    print(f"x = {int(resultado.x[0])}, y = {int(resultado.x[1])}, z = {int(resultado.x[2])}")
    print(f"Valor de la función objetivo: {-resultado.fun}")
else:
    print("No se encontró solución:", resultado.message)

# EJERCICIO 3
import numpy as np
import pandas as pd
import statsmodels.api as sm

# Datos de llegadas semanales
llegadas = np.array([28, 27, 44, 37, 35, 53, 38, 57, 61, 39, 55, 54, 52, 60, 60, 75])

# Número de semanas
n = len(llegadas)

pms = []  # Promedio Móvil Simple
pmp = []  # Promedio Móvil Ponderado
se = []   # Suavización Exponencial

# Promedio Móvil Simple (PMS)
for i in range(3, n):
    pms.append(np.mean(llegadas[i - 3:i]))

# Promedio Móvil Ponderado (PMP)
for i in range(3, n):
    pmp.append(0.6*llegadas[i - 1] + 0.3*llegadas[i - 2] + 0.1*llegadas[i - 3])

# Suavización Exponencial (SE)
alpha = 0.4
se.append(26)
for i in range(1, n):
    se.append(alpha*llegadas[i - 1] + (1 - alpha)*se[-1])

# Calcular errores
def calcular_errores(pronosticos, llegadas_reales, alineacion):
    errores = np.array(pronosticos) - llegadas_reales[alineacion:]
    mse = np.mean(errores**2)
    mae = np.mean(np.abs(errores))
    mape = np.mean(np.abs(errores / llegadas_reales[alineacion:]))*100
    return mse, mae, mape

# Calcular errores para cada método
mse_pms, mae_pms, mape_pms = calcular_errores(pms, llegadas, 3)
mse_pmp, mae_pmp, mape_pmp = calcular_errores(pmp, llegadas, 3)
mse_se, mae_se, mape_se = calcular_errores(se, llegadas, 0)

print("Resultados de Pronósticos:")
print(f"Promedio Móvil Simple: MSE={mse_pms:.2f}, MAE={mae_pms:.2f}, MAPE={mape_pms:.2f}%")
print(f"Promedio Móvil Ponderado: MSE={mse_pmp:.2f}, MAE={mae_pmp:.2f}, MAP={mape_pmp:.2f}%")
print(f"Suavización Exponencial: MSE={mse_se:.2f}, MAE={mae_se:.2f}, MAPE={mape_se: .2f}%")

# Presentación Ejercicio 3

import matplotlib.pyplot as plt

# Dimension X correponde a las semanas
x = np.arange(1, n + 1)

plt.plot(x, llegadas, label='Llegadas reales')
plt.plot(x[3:], pms, label='Promedio Móvil Simple')
plt.plot(x[3:], pmp, label='Promedio Móvil Ponderado')
plt.plot(x, se, label='Suavización Exponencial')

plt.xlabel('Semanas')
plt.ylabel('Llegadas Semanales')
plt.title('Pronósticos de Llegadas Semanales')
plt.legend()
plt.grid(True)
plt.show()